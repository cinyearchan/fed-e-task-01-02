### 函数式编程

#### 介绍

- 学习函数式编程原因及函数式编程的概念
- 函数式编程的特性（纯函数、柯里化、函数组合等）
- 函数式编程的应用场景
- 函数式编程库 Lodash



#### 原因

- 函数式编程随着 React 的流行而受到越来越多的关注
- Vue 3 也开始拥抱函数式编程
- 函数式编程可以抛弃 this
- 打包过程中可以更好地利用 tree shaking 过滤无用代码
- 方便测试、方便并行处理
- 有很多库可以帮助我们进行函数式开发：lodash、underscore、ramda

#### 概念

- 程序的本质：根据输入通过某种运算获得相应的输出，程序开发过程中会涉及很多输入和输出的函数
- x -> f(联系、映射) -> y, y = f(x)
- **函数式编程中的函数指的不是程序中的函数（方法）**，而是数学中的函数即映射关系，例如：y = sin(x)，x 和 y 的关系
- **相同的输入始终要得到相同的输出**（纯函数）
- 函数式编程用来描述数据（函数）之间的映射



---



#### 函数是一等公民

JS 中的函数就是一个普通的对象（可以通过`new Function()`），可以把函数存储到变量、数组中，也可以作为另一个函数的参数和返回值，甚至可以在程序运行时通过 `new Function('alert(1)')` 来构造一个新的函数

- 函数可以存储在变量中

```javascript
let fn = function () {
  console.log('Hello First-class Function')
}
fn()

// example
const BlogController = {
  index (posts) { return Views.index(posts) },
  show (post) { return Views.show(post) },
  create (attrs) { return Db.create(attrs) },
  update (post, attrs) { return Db.update(post, attrs) },
  destroy (post) { return Db.destroy(post) }
}

// 优化
const BlogController = {
  index: Views.index,
  show: Views.show,
  create: Db.create,
  update: Db.update,
  destroy: Db.destroy
}
```



#### 高阶函数

- 可以把函数作为参数传递给另一个函数
- 可以把函数作为另一个函数的返回结果



##### 函数作为参数

```javascript
// 模拟 forEach
function forEach (array, fn) {
  for (let i = 0; i < array.length; i++) {
    fn(array[i])
  }
}

// 测试
let arr = [1, 3, 4, 5, 7, 8]
forEach(arr, function (item) {
  console.log(item)
})
// 1 3 4 5 7 8

// 模拟 filter
function filter (array, fn) {
  let results = []
  for (let i = 0; i < array.length; i++) {
    if (fn(array[i])) {
      results.push(array[i])
    }
  }
  return results
}

// 测试
let arr = [1, 3, 4, 5, 7, 8]
let r = filter(arr, function (item) {
  return item % 2 === 0
})
console.log(r) // [4, 8]
```



##### 函数作为返回值

```javascript
function makeFn () {
  let msg = 'Hello function'
  return function () {
    console.log(msg)
  }
}

const fn = makeFn()

fn() // Hello function
makeFn()() // Hello function

// once 函数
function once (fn) {
  let done = false
  return function () {
    if (!done){
      done = true
      return fn.apply(this, arguments)
    }
  }
}

let pay = once(function (money) {
  console.log(`支付：${money} RMB`)
})

pay(5) // 支付：5 RMB // 只执行一次
pay(5)
pay(5)
pay(5)
```



##### 使用高阶函数的意义

- 抽象可以帮助我们屏蔽细节，只需要关注我们的目标
- 高阶函数是用来抽象通用的问题

```javascript
// 以循环打印数组为例
// 面向过程的方式
let array = [1, 2, 3, 4]
for (let i = 0; i < array.length; i++) {
  console.log(array[i])
}

// 高阶函数
let array = [1, 2, 3, 4]
forEach(array, item => {
  console.log(item)
})

let r = filter(array, item => {
  return item % 2 === 0
})
```



##### 常用的高阶函数

`forEach`、`map`、`filter`、`every`、`some`、`find/findIndex`、`reduce`、`sort`

```javascript
// 模拟常用高阶函数 map every some

// map
const map = (array, fn) => {
  let results = []
  for (const value of array) {
    reuslts.push(fn(value))
  }
  return results
}
// 测试
let arr = [1, 2, 3, 4]
arr = map(arr, v => v * v)
console.log(arr) // [1, 4, 9, 16]

// every
const every = (array, fn) => {
  let result = true
  for (const value of array) {
    result = fn(value)
    if (!result) {
      break
    }
  }
  return result
}
// 测试
let arr = [11, 12, 14]
let r = every(arr, v => v > 10)
console.log(r) // true

// some
const some = (array, fn) => {
  let result = false
  for (const value of array) {
    result = fn(value)
    if (result) {
      break
    }
  }
  return result
}
// 测试
let arr = [1, 3, 4, 9]
let r = some(arr, v => v % 2 === 0)
console.log(r) // true
```



---



#### 闭包

函数和其周围的状态（词法作用域）的引用捆绑在一起形成闭包

- 可以在另一个作用域中调用一个函数的内部函数并访问到该函数的作用域中的成员

以上述“函数作为返回值”为例：

```javascript
function makeFn () {
  let msg = 'Hello function'
  return function () {
    console.log(msg)
  }
}

const fn = makeFn()
fn()
```

> 闭包的本质：函数在执行时会放到一个执行栈上，当函数执行完毕之后会从执行栈上移除，**但是堆上的作用域成员因为被外部引用不能释放**，因此内部函数依然可以访问外部函数的成员



##### 闭包案例

对给定数字求幂运算

```javascript
Math.pow(4, 2)
Math.pow(5, 2)
```

优化

```javascript
function makePower (power) {
  return function (number) {
    return Math.pow(number, power)
  }
}

// 求平方
let power2 = makePower(2)
// 求立方
let power3 = makePower(3)

console.log(power2(4)) // 16
console.log(power2(5)) // 25
console.log(power3(4)) // 64
```



---



#### 纯函数

##### 概念

相同的输入永远会得到相同的输出，而且没有任何可观察的副作用（类似于数学中的函数，用来描述输入与输出之间的关系， `y = f(x)`）




> lodash 是一个纯函数的功能库，提供了对数组、数字、对象、字符串、函数等操作的一些方法



##### 对比

数组的 `slice` 和 `splice` 分别是：纯函数和不纯的函数

-  `slice` 返回数组中的指定部分，不会改变原数组
-  `splice` 对数组进行操作返回该数组，会改变原数组

```javascript
let array = [1, 2, 3, 4, 5]
// slice
console.log(array.slice(0, 3)) // [1, 2, 3]
console.log(array.slice(0, 3)) // [1, 2, 3]
console.log(array.slice(0, 3)) // [1, 2, 3]

// splice
console.log(array.splice(0, 3)) // [1, 2, 3]
console.log(array.splice(0, 3)) // [4, 5]
console.log(array.splice(0, 3)) // []
```



函数式编程不会保留计算中间的结果，所以变量是不可变的（无状态的）

因此可以把一个函数的执行结果交给另一个函数去处理



##### Lodash

`first`、`last`、`toUpper`、`reverse`、`each`、`includes`、`find`、`findIndex`

```javascript
const _ = require('lodash')

const array = ['jack', 'tom', 'lucy', 'kate']

console.log(_.first(array)) // jack
console.log(_.last(array)) // kate

console.log(_.toUpper(_.first(array))) // JACK

console.log(_.reverse(array)) // ['kate', 'lucy', 'tom', 'jack']

const r = _.each(array, (item, index) => {
  console.log(item, index)
})
console.log(r)
// kate 0
// lucy 1
// tom 2
// jack 3
// ['kate', 'lucy', 'tom', 'jack']

```



##### 纯函数的好处

- 可缓存

因为纯函数对相同的输入始终有相同的结果，所以可以把纯函数的结果缓存起来

```javascript
// lodash 中的记忆函数
const _ = require('lodash')

// 求正方形面积的纯函数
function getArea (r) {
  return r * r
}

let getAreaWithMemory = _.memoize(getArea)
console.log(getAreaWithMemory(4)) // 16
console.log(getAreaWithMemory(4)) // 16
console.log(getAreaWithMemory(4)) // 16

// 模拟 lodash 中的记忆函数 memoize
function memoize (f) {
  let cache = {}
  return function () {
    let key = JSON.stringify(arguments)
    cache[key] = cache[key] || f.apply(f, arguments)
    return cache[key]
  }
}

let getAreaWithMemory = memoize(getArea)
console.log(getAreaWithMemory(4)) // 16
console.log(getAreaWithMemory(4)) // 16
console.log(getAreaWithMemory(4)) // 16

```



- 可测试（纯函数让测试更方便）
- 并行处理
  - 在多线程环境下并行操作共享的内存数据很可能会出现意外情况
  - 纯函数不需要访问共享的内存数据，所以在并行环境下可以任意运行纯函数（Web Worker）



##### 函数的副作用

```javascript
// 不纯的
let mini = 18
function checkAge (age) {
  return age >= mini
}
// 对于给定的输入，无法确保输出是一定的，因为全局变量 mini 可能会变

// 纯的（有硬编码，后续可以通过柯里化解决）
function checkAge (age) {
  let mini = 18
  return age >= mini
}
```



> 副作用让一个函数变的不纯，纯函数会根据相同的输入返回相同的输出，如果函数依赖于外部的状态就无法保证输出相同，就会带来副作用



副作用的来源：配置文件、数据库、获取用户的输入等

所有的外部交互都有可能带来副作用，副作用也使得方法通用性下降，不利于拓展和可重用性，同时副作用会给程序带来安全隐患和不确定性，但是副作用不可能完全禁止，尽可能控制它们在可控范围内发生

